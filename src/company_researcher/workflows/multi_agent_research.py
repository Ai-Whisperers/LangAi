"""
Multi-Agent Research Workflow (Phase 3).

This workflow implements a two-agent system:
- Researcher Agent: Finds and gathers sources
- Analyst Agent: Extracts structured insights

Workflow: Researcher → Analyst → Quality Check → (iterate or finish)
"""

from typing import Dict, Any
from datetime import datetime
from langgraph.graph import StateGraph, END

from ..state import OverallState, InputState, OutputState, create_initial_state, create_output_state
from ..agents import researcher_agent_node, analyst_agent_node
from ..quality import check_research_quality
from ..prompts import format_sources_for_report


# ============================================================================
# Workflow Nodes
# ============================================================================

def check_quality_node(state: OverallState) -> Dict[str, Any]:
    """
    Node: Check research quality (Phase 2).

    Args:
        state: Current workflow state

    Returns:
        State update with quality assessment
    """
    print("\n[NODE] Checking research quality...")

    # Check quality
    quality_result = check_research_quality(
        company_name=state["company_name"],
        extracted_data=state.get("company_overview", ""),
        sources=state.get("sources", [])
    )

    quality_score = quality_result["quality_score"]
    print(f"[QUALITY] Score: {quality_score:.1f}/100")

    if quality_score < 85:
        print("[QUALITY] Below threshold (85). Missing information:")
        for item in quality_result["missing_information"][:3]:
            print(f"  - {item}")

    return {
        "quality_score": quality_score,
        "missing_info": quality_result["missing_information"],
        "iteration_count": state.get("iteration_count", 0) + 1,
        "total_cost": state.get("total_cost", 0.0) + quality_result["cost"],
        "total_tokens": {
            "input": state.get("total_tokens", {"input": 0, "output": 0})["input"] + quality_result["tokens"]["input"],
            "output": state.get("total_tokens", {"input": 0, "output": 0})["output"] + quality_result["tokens"]["output"]
        }
    }


def save_report_node(state: OverallState) -> Dict[str, Any]:
    """
    Node: Save markdown report.

    Args:
        state: Current workflow state

    Returns:
        State update with report path
    """
    print("\n[NODE] Generating markdown report...")

    # Generate report content
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    company_name = state["company_name"]

    # Get agent outputs for attribution
    agent_outputs = state.get("agent_outputs", {})
    researcher_metrics = agent_outputs.get("researcher", {})
    analyst_metrics = agent_outputs.get("analyst", {})

    # Calculate duration
    duration = (datetime.now() - state.get("start_time", datetime.now())).total_seconds()

    # Build report
    report_content = f"""# {company_name} - Research Report

*Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*

---

{state.get("company_overview", "Not available in research")}

---

## Sources

{format_sources_for_report(state.get("sources", []))}

---

*This report was automatically generated by the Company Researcher System*
*Quality Score: {state.get('quality_score', 0):.1f}/100 | Iterations: {state.get('iteration_count', 0)} | Duration: {duration:.1f}s | Cost: ${state.get('total_cost', 0.0):.4f} | Sources: {len(state.get('sources', []))}*

---

## Multi-Agent System Metrics (Phase 3)

### Researcher Agent
- Queries Generated: {researcher_metrics.get('queries_generated', 0)}
- Sources Found: {researcher_metrics.get('sources_found', 0)}
- Cost: ${researcher_metrics.get('cost', 0.0):.4f}

### Analyst Agent
- Sources Analyzed: {analyst_metrics.get('sources_analyzed', 0)}
- Data Extracted: {analyst_metrics.get('data_extracted', False)}
- Cost: ${analyst_metrics.get('cost', 0.0):.4f}

---
"""

    # Save report
    import os
    output_dir = f"outputs/{company_name}"
    os.makedirs(output_dir, exist_ok=True)

    report_path = f"{output_dir}/report_{timestamp}.md"

    with open(report_path, "w", encoding="utf-8") as f:
        f.write(report_content)

    print(f"[OK] Report saved to: {report_path}")

    return {"report_path": report_path}


# ============================================================================
# Decision Functions
# ============================================================================

def should_continue_research(state: OverallState) -> str:
    """
    Decision function: Should we iterate or finish?

    Args:
        state: Current workflow state

    Returns:
        "iterate" to continue research, "finish" to complete
    """
    quality_score = state.get("quality_score", 0)
    iteration_count = state.get("iteration_count", 0)
    max_iterations = 2  # Maximum 2 iterations

    # Finish if quality is good enough OR max iterations reached
    if quality_score >= 85:
        print(f"[DECISION] Quality sufficient ({quality_score:.1f} >= 85). Proceeding to report.")
        return "finish"
    elif iteration_count >= max_iterations:
        print(f"[DECISION] Max iterations reached ({iteration_count}/{max_iterations}). Proceeding to report.")
        return "finish"
    else:
        print(f"[DECISION] Quality low ({quality_score:.1f} < 85), iteration {iteration_count}/{max_iterations}. Re-searching.")
        return "iterate"


# ============================================================================
# Workflow Creation
# ============================================================================

def create_multi_agent_workflow() -> StateGraph:
    """
    Create the multi-agent research workflow (Phase 3).

    Workflow:
        researcher → analyst → check_quality → (iterate or finish)

    Returns:
        Compiled StateGraph workflow
    """
    # Create graph
    workflow = StateGraph(OverallState, input=InputState, output=OutputState)

    # Add nodes
    workflow.add_node("researcher", researcher_agent_node)
    workflow.add_node("analyst", analyst_agent_node)
    workflow.add_node("check_quality", check_quality_node)
    workflow.add_node("save_report", save_report_node)

    # Define edges
    workflow.set_entry_point("researcher")
    workflow.add_edge("researcher", "analyst")  # Agent handoff
    workflow.add_edge("analyst", "check_quality")

    # Conditional edge from check_quality
    workflow.add_conditional_edges(
        "check_quality",
        should_continue_research,
        {
            "iterate": "researcher",  # Loop back to improve
            "finish": "save_report"  # Quality is good, save report
        }
    )

    workflow.add_edge("save_report", END)

    return workflow.compile()


# ============================================================================
# Main Research Function
# ============================================================================

def research_company(company_name: str) -> OutputState:
    """
    Research a company using the multi-agent workflow.

    Args:
        company_name: Name of company to research

    Returns:
        OutputState with results and metrics
    """
    print(f"\n{'='*60}")
    print(f"[WORKFLOW] Multi-Agent Research: {company_name}")
    print(f"{'='*60}")

    # Create workflow
    workflow = create_multi_agent_workflow()

    # Create initial state
    initial_state = create_initial_state(company_name)

    # Run workflow
    final_state = workflow.invoke(initial_state)

    # Convert to output state
    output = create_output_state(final_state)

    # Print summary
    print(f"\n{'='*60}")
    print("[RESULTS] Multi-Agent Research Complete")
    print(f"{'='*60}")
    print(f"Report: {output['report_path']}")
    print(f"Duration: {output['metrics']['duration_seconds']:.1f}s")
    print(f"Cost: ${output['metrics']['cost_usd']:.4f}")
    print(f"Tokens: {output['metrics']['tokens']['input']:,} in, {output['metrics']['tokens']['output']:,} out")
    print(f"Sources: {output['metrics']['sources_count']}")
    print(f"Quality: {output['metrics']['quality_score']:.1f}/100")
    print(f"Iterations: {output['metrics']['iterations']}")
    print(f"{'='*60}\n")

    return output
