"""
Comprehensive Output Nodes for Multi-Section Report Generation.

This module contains nodes for generating comprehensive reports with:
- Executive summary
- Financial analysis
- Market analysis
- ESG analysis
- Brand analysis
- Competitive landscape
- Risk assessment
- Investment thesis
- News sentiment
- Sources
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional

from ...state import OverallState
from ...config import get_config

logger = logging.getLogger(__name__)


# =============================================================================
# Comprehensive Report Generation Node
# =============================================================================

def save_comprehensive_report_node(state: OverallState) -> Dict[str, Any]:
    """
    Generate and save comprehensive markdown report with all analyses.
    """
    config = get_config()

    logger.info("[NODE] Generating comprehensive report...")

    duration = (datetime.now() - state.get("start_time", datetime.now())).total_seconds()

    # Create output directory
    output_dir = Path(config.output_dir) / state["company_name"].replace(" ", "_").lower()
    output_dir.mkdir(parents=True, exist_ok=True)

    # Generate timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    # Format all sections
    sections = {
        "overview": state.get("company_overview", "*No overview available*"),
        "financial": _format_agent_output("Financial Analysis", state.get("agent_outputs", {}).get("financial")),
        "market": _format_agent_output("Market Analysis", state.get("agent_outputs", {}).get("market")),
        "esg": _format_agent_output("ESG Analysis", state.get("agent_outputs", {}).get("esg")),
        "brand": _format_agent_output("Brand Analysis", state.get("agent_outputs", {}).get("brand")),
        "sentiment": _format_news_sentiment(state.get("news_sentiment")),
        "competitive": _format_competitive_analysis(state.get("competitive_matrix")),
        "risk": _format_risk_profile(state.get("risk_profile")),
        "investment": _format_investment_thesis(state.get("investment_thesis")),
        "sources": _format_sources_report(state.get("sources", [])),
    }

    # Generate full report
    report_content = f"""# {state['company_name']} - Comprehensive Research Report

*Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
*Region: {state.get('detected_region', 'Unknown')} | Language: {state.get('detected_language', 'Unknown')}*

---

## Executive Summary

{sections['overview']}

---

## Financial Analysis

{sections['financial']}

---

## Market Analysis

{sections['market']}

---

## ESG Analysis

{sections['esg']}

---

## Brand & Reputation

{sections['brand']}

---

## News Sentiment

{sections['sentiment']}

---

## Competitive Landscape

{sections['competitive']}

---

## Risk Assessment

{sections['risk']}

---

## Investment Thesis

{sections['investment']}

---

## Sources

{sections['sources']}

---

## Research Metrics

| Metric | Value |
|--------|-------|
| Quality Score | {state.get('quality_score', 0):.1f}/100 |
| Iterations | {state.get('iteration_count', 0)} |
| Duration | {duration:.1f}s |
| Total Cost | ${state.get('total_cost', 0.0):.4f} |
| Sources Used | {len(state.get('sources', []))} |
| Contradictions Found | {len(state.get('contradictions', []))} |

---

*This report was automatically generated by the Company Researcher System (Comprehensive Mode)*
"""

    # Save full report
    report_path = output_dir / f"00_full_report.md"
    with open(report_path, "w", encoding="utf-8") as f:
        f.write(report_content)

    # Save individual section files
    section_files = [
        ("01_executive_summary.md", "Executive Summary", sections["overview"]),
        ("02_financial_analysis.md", "Financial Analysis", sections["financial"]),
        ("03_market_analysis.md", "Market Analysis", sections["market"]),
        ("04_esg_analysis.md", "ESG Analysis", sections["esg"]),
        ("05_brand_analysis.md", "Brand & Reputation", sections["brand"]),
        ("06_competitive_analysis.md", "Competitive Landscape", sections["competitive"]),
        ("07_risk_assessment.md", "Risk Assessment", sections["risk"]),
        ("08_investment_thesis.md", "Investment Thesis", sections["investment"]),
        ("09_sources.md", "Sources", sections["sources"]),
    ]

    for filename, title, content in section_files:
        filepath = output_dir / filename
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(f"# {state['company_name']} - {title}\n\n{content}")

    # Save metrics JSON
    metrics = {
        "company_name": state["company_name"],
        "quality_score": state.get("quality_score", 0),
        "iterations": state.get("iteration_count", 0),
        "duration_seconds": duration,
        "total_cost": state.get("total_cost", 0.0),
        "sources_count": len(state.get("sources", [])),
        "contradictions_count": len(state.get("contradictions", [])),
        "confidence_scores": state.get("confidence_scores", {}),
        "source_quality": state.get("source_quality", {}),
        "timestamp": timestamp,
    }

    metrics_path = output_dir / "metrics.json"
    with open(metrics_path, "w", encoding="utf-8") as f:
        json.dump(metrics, f, indent=2)

    logger.info(f"[OK] Comprehensive report saved: {report_path}")

    return {
        "report_path": str(report_path),
        "output_dir": str(output_dir),
    }


# =============================================================================
# Formatter Functions
# =============================================================================

def _format_agent_output(title: str, content: Optional[str]) -> str:
    """Format an agent's output."""
    if not content:
        return f"*No {title.lower()} available*"
    return content


def _format_news_sentiment(sentiment: Optional[Dict]) -> str:
    """Format news sentiment section."""
    if not sentiment:
        return "*No news sentiment analysis available*"

    sections = [
        f"**Overall Sentiment:** {sentiment.get('sentiment_level', 'N/A')}",
        f"**Score:** {sentiment.get('sentiment_score', 0):.2f}",
        f"**Trend:** {sentiment.get('sentiment_trend', 'N/A')}",
        f"**Articles Analyzed:** {sentiment.get('total_articles', 0)}",
    ]

    topics = sentiment.get("key_topics", [])
    if topics:
        sections.append(f"\n**Key Topics:** {', '.join(topics)}")

    positives = sentiment.get("positive_highlights", [])
    if positives:
        sections.append("\n### Positive Coverage")
        for p in positives[:3]:
            sections.append(f"- {p}")

    negatives = sentiment.get("negative_highlights", [])
    if negatives:
        sections.append("\n### Areas of Concern")
        for n in negatives[:3]:
            sections.append(f"- {n}")

    return "\n".join(sections)


def _format_competitive_analysis(matrix: Optional[Dict]) -> str:
    """Format competitive matrix section."""
    if not matrix:
        return "*No competitive analysis available*"

    sections = []
    company = matrix.get("company", {})
    sections.append(f"### Target: {company.get('name', 'N/A')}")
    if company.get("position"):
        sections.append(f"**Position:** {company.get('position')}")

    competitors = matrix.get("competitors", [])
    if competitors:
        sections.append("\n### Key Competitors")
        for c in competitors:
            sections.append(f"- **{c.get('name', 'N/A')}** ({c.get('position', 'Unknown')})")

    insights = matrix.get("insights", [])
    if insights:
        sections.append("\n### Strategic Insights")
        for i in insights[:5]:
            sections.append(f"- {i}")

    return "\n".join(sections)


def _format_risk_profile(profile: Optional[Dict]) -> str:
    """Format risk profile section."""
    if not profile:
        return "*No risk assessment available*"

    sections = [
        f"**Risk Grade:** {profile.get('grade', 'N/A')}",
        f"**Risk Score:** {profile.get('overall_score', 0):.1f}/100",
    ]

    category_scores = profile.get("category_scores", {})
    if category_scores:
        sections.append("\n### Risk by Category")
        for cat, score in category_scores.items():
            sections.append(f"- **{cat.replace('_', ' ').title()}:** {score:.1f}/100")

    risks = profile.get("risks", [])
    if risks:
        sections.append("\n### Key Risks")
        for r in risks[:5]:
            sections.append(f"- **{r.get('description', 'N/A')}** ({r.get('severity', 'Unknown')} severity)")
            if r.get("mitigation"):
                sections.append(f"  - *Mitigation:* {r.get('mitigation')}")

    return "\n".join(sections)


def _format_investment_thesis(thesis: Optional[Dict]) -> str:
    """Format investment thesis section."""
    if not thesis:
        return "*No investment thesis available*"

    sections = [
        f"### Recommendation: **{thesis.get('recommendation', 'N/A')}**",
        f"**Confidence:** {thesis.get('confidence', 0) * 100:.0f}%",
        f"**Time Horizon:** {thesis.get('target_horizon', 'N/A')}",
    ]

    if thesis.get("summary"):
        sections.append(f"\n{thesis.get('summary')}")

    bull = thesis.get("bull_case", {})
    if bull:
        sections.append("\n### Bull Case")
        sections.append(f"**Thesis:** {bull.get('thesis', 'N/A')}")
        sections.append(f"**Upside:** {bull.get('upside_potential', 0):.1f}%")

    bear = thesis.get("bear_case", {})
    if bear:
        sections.append("\n### Bear Case")
        sections.append(f"**Thesis:** {bear.get('thesis', 'N/A')}")
        sections.append(f"**Downside:** {bear.get('downside_risk', 0):.1f}%")

    suitable = thesis.get("suitable_for", [])
    if suitable:
        sections.append(f"\n**Suitable For:** {', '.join(suitable)}")

    return "\n".join(sections)


def _format_sources_report(sources: List[Dict]) -> str:
    """Format sources section."""
    if not sources:
        return "*No sources available*"

    sections = []
    for i, s in enumerate(sources[:20], 1):
        sections.append(f"{i}. [{s.get('title', 'Unknown')}]({s.get('url', '#')})")

    return "\n".join(sections)
