---
id: templar.cicd.azure-pipelines-unified.v1
kind: templar
version: 1.0.0
description: Unified Azure Pipelines template for .NET
implements: cicd.pipeline.create
provenance:
  owner: team-cicd
  last_review: 2025-12-05
---
# UNIFIED REFERENCE CI/CD PIPELINE
# Tag-Based Versioning with Two-Stage RC Workflow
# 
# IMPLEMENTATION STATUS: 60/60 (Gold Standard)
# - âœ… Full 5-stage pipeline operational
# - âœ… Tag parsing and version extraction
# - âœ… Security scanning and SBOM generation
# - âœ… Branch-specific coverage thresholds (70%/75%/80%)
# - âœ… Automated NuGet publishing to TEST and PROD feeds
#
# TWO-STAGE RC WORKFLOW:
# 1. test-X.Y.Z-rcN   â†’ Internal testing (TEST feed)
# 2. release-X.Y.Z-rcN â†’ External/consumer testing (PROD feed as NuGet prerelease)
# 3. release-X.Y.Z     â†’ GA release (PROD feed as stable) - SAME CODE as last RC
#
# MAINTENANCE RELEASES (when main is on newer major version):
# - Tag release-X.Y.Z directly on release/X.Y branch (NO merge to main)
#
# REFERENCE: eneve.domain (deployed and operational at 60/60)
# RULE: rule.cicd.tag-based-versioning.v2
#
# Deploy this template to: foundation, domain, datamigrator

# =============================================================================
# TRIGGER CONFIGURATION
# =============================================================================

# Branch-based CI: Runs Stages 1-4 (Build, Security, Coverage, Package Artifacts)
trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
      - hotfix/*
      - release/*
  paths:
    include:
      - src/**
      - tst/**

# Tag-based CD: Runs all 5 stages, packages and publishes
# TWO-STAGE RC WORKFLOW:
#   test-1.2.0-rc1     â†’ TEST feed (internal QA)
#   release-1.2.0-rc1  â†’ PROD feed (NuGet prerelease, consumers opt-in with --prerelease)
#   release-1.2.0      â†’ PROD feed (stable GA, same code as last release RC)
trigger:
  tags:
    include:
      - release-*     # Production: release-1.0.0 (GA), release-1.0.0-rc1 (prerelease)
      - test-*        # Internal testing: test-1.0.0-rc1 (TEST feed only)
      - coverage-*    # Coverage analysis only (no publishing)

# Pull Request validation
pr:
  branches:
    include:
      - main
      - develop

# =============================================================================
# VARIABLES
# =============================================================================

variables:
  buildConfiguration: 'Release'
  dotnetVersion: '9.x'
  solutionPath: '**/*.sln'  # Adjust per repo
  
  # Dynamic coverage threshold based on branch/tag
  ${{ if or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/tags/release-')) }}:
    coverageThreshold: 80
  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    coverageThreshold: 75
  ${{ else }}:
    coverageThreshold: 70
  
  # Determine if this is a tag-triggered build
  isTagBuild: ${{ startsWith(variables['Build.SourceBranch'], 'refs/tags/') }}

pool:
  vmImage: 'windows-latest'

# =============================================================================
# STAGE 1: BUILD & VALIDATE
# =============================================================================

stages:
- stage: Build_and_Validate
  displayName: 'Build, Test, and Validate'
  jobs:
  - job: Build
    displayName: 'Build and Test'
    steps:
    
    # Install .NET SDK
    - task: UseDotNet@2
      displayName: 'Install .NET SDK $(dotnetVersion)'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetVersion)'
        installationPath: $(Agent.ToolsDirectory)/dotnet

    # Restore NuGet packages
    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: '$(solutionPath)'
        feedsToUse: 'select'
        # nugetConfigPath: 'NuGet.Config' # Optional if using config file

    # Build solution with strict warnings
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution (Warnings as Errors)'
      inputs:
        command: 'build'
        projects: '$(solutionPath)'
        arguments: '--configuration $(buildConfiguration) --no-restore /p:TreatWarningsAsErrors=true /p:ContinuousIntegrationBuild=true'
      continueOnError: false

    # Verify XML documentation files were generated
    - task: PowerShell@2
      displayName: 'Verify XML Documentation Files'
      inputs:
        targetType: 'filePath'
        filePath: 'cicd/scripts/verify-xml-files.ps1'
        arguments: '-Configuration $(buildConfiguration)'
      continueOnError: false

    # Run unit tests with code coverage
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests with Coverage'
      inputs:
        command: 'test'
        projects: 'tst/**/*.Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/TestResults -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
        publishTestResults: true

    # Validate documentation completeness
    - task: PowerShell@2
      displayName: 'Validate Documentation Quality'
      inputs:
        targetType: 'filePath'
        filePath: 'cicd/scripts/validate-documentation.ps1'
        arguments: '-Configuration $(buildConfiguration)'
      continueOnError: false

    # Publish raw code coverage results
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage'
      inputs:
        summaryFileLocation: '$(Agent.TempDirectory)/TestResults/**/coverage.cobertura.xml'
        failIfCoverageEmpty: false

# =============================================================================
# STAGE 2: SECURITY SCAN
# =============================================================================

- stage: Security_Scan
  displayName: 'Security Scanning'
  dependsOn: Build_and_Validate
  condition: succeeded()
  jobs:
  - job: VulnerabilityScan
    displayName: 'Vulnerability Analysis'
    steps:
    
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        version: $(dotnetVersion)

    # Restore packages for scanning
    - task: DotNetCoreCLI@2
      displayName: 'Restore Packages'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'
        feedsToUse: 'select'
        # nugetConfigPath: 'NuGet.Config'

    # Scan for vulnerable packages
    - task: PowerShell@2
      displayName: 'Scan for Vulnerabilities'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=" * 80
          Write-Host "SECURITY VULNERABILITY SCAN"
          Write-Host "=" * 80
          
          $result = dotnet list package --vulnerable --include-transitive 2>&1
          
          if ($result -match "has the following vulnerable packages") {
            Write-Host ""
            Write-Host "âš ï¸  VULNERABLE PACKAGES DETECTED!" -ForegroundColor Yellow
            Write-Host ""
            Write-Host $result
            
            # Count severity levels
            $critical = ($result | Select-String -Pattern "Critical" -AllMatches).Matches.Count
            $high = ($result | Select-String -Pattern "High" -AllMatches).Matches.Count
            $moderate = ($result | Select-String -Pattern "Moderate" -AllMatches).Matches.Count
            $low = ($result | Select-String -Pattern "Low" -AllMatches).Matches.Count
            
            Write-Host ""
            Write-Host "Vulnerability Summary:" -ForegroundColor Yellow
            Write-Host "  ðŸ”´ Critical: $critical"
            Write-Host "  ðŸŸ  High: $high"
            Write-Host "  ðŸŸ¡ Moderate: $moderate"
            Write-Host "  ðŸ”µ Low: $low"
            Write-Host ""
            
            # Fail on Critical or High
            if ($result -match "Critical|High") {
              Write-Host "##vso[task.logissue type=error]Critical or High severity vulnerabilities found!"
              Write-Host "âŒ BUILD FAILED: Security vulnerabilities must be resolved!" -ForegroundColor Red
              exit 1
            } else {
              Write-Host "##vso[task.logissue type=warning]Moderate or Low severity vulnerabilities detected"
              Write-Host "âš ï¸  Warning: Consider updating vulnerable packages" -ForegroundColor Yellow
            }
          } else {
            Write-Host ""
            Write-Host "âœ… NO VULNERABLE PACKAGES FOUND!" -ForegroundColor Green
            Write-Host ""
            Write-Host "##vso[task.complete result=Succeeded;]Security scan passed"
          }

# =============================================================================
# STAGE 3: COVERAGE THRESHOLD & REPORTING
# =============================================================================

- stage: Coverage_Analysis
  displayName: 'Coverage Threshold Enforcement'
  dependsOn: Build_and_Validate
  condition: succeeded()
  jobs:
  - job: CoverageCheck
    displayName: 'Check Coverage Threshold'
    steps:
    
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        version: $(dotnetVersion)

    # Restore and build for coverage analysis
    - task: DotNetCoreCLI@2
      displayName: 'Restore and Build'
      inputs:
        command: 'build'
        projects: '$(solutionPath)'
        arguments: '--configuration $(buildConfiguration)'

    # Run tests with coverage
    - task: DotNetCoreCLI@2
      displayName: 'Run Tests with Coverage'
      inputs:
        command: 'test'
        projects: 'tst/**/*.Tests.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/TestResults'

    # Install ReportGenerator
    - task: DotNetCoreCLI@2
      displayName: 'Install ReportGenerator'
      inputs:
        command: 'custom'
        custom: 'tool'
        arguments: 'install --global dotnet-reportgenerator-globaltool'

    # Generate HTML coverage report and check threshold
    - task: PowerShell@2
      displayName: 'Generate Coverage Report & Check Threshold'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=" * 80
          Write-Host "CODE COVERAGE ANALYSIS"
          Write-Host "=" * 80
          
          $coverageFiles = Get-ChildItem -Path "$(Agent.TempDirectory)/TestResults" -Recurse -Filter "coverage.cobertura.xml"
          
          if ($coverageFiles.Count -eq 0) {
            Write-Host "##vso[task.logissue type=warning]No coverage files found"
            Write-Host "âš ï¸  Warning: No coverage data available" -ForegroundColor Yellow
            exit 0
          }
          
          Write-Host ""
          Write-Host "Found $($coverageFiles.Count) coverage file(s)"
          Write-Host ""
          
          # Merge coverage files and generate HTML report
          $inputFiles = ($coverageFiles | ForEach-Object { $_.FullName }) -join ";"
          reportgenerator "-reports:$inputFiles" "-targetdir:$(Build.ArtifactStagingDirectory)/coverage" "-reporttypes:Cobertura;HtmlSummary;Html"
          
          # Parse coverage percentage
          [xml]$coverage = Get-Content "$(Build.ArtifactStagingDirectory)/coverage/Cobertura.xml"
          $lineRate = [double]$coverage.coverage.'line-rate' * 100
          $branchRate = [double]$coverage.coverage.'branch-rate' * 100
          
          Write-Host "Coverage Results:" -ForegroundColor Cyan
          Write-Host "  Line Coverage:   $([math]::Round($lineRate, 2))%"
          Write-Host "  Branch Coverage: $([math]::Round($branchRate, 2))%"
          Write-Host "  Required Threshold: $(coverageThreshold)%"
          Write-Host ""
          
          if ($lineRate -lt $(coverageThreshold)) {
            Write-Host "##vso[task.logissue type=error]Code coverage ($([math]::Round($lineRate, 2))%) is below threshold ($(coverageThreshold)%)"
            Write-Host "âŒ BUILD FAILED: Coverage below threshold!" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "âœ… Coverage threshold met!" -ForegroundColor Green
          Write-Host "##vso[task.complete result=Succeeded;]Coverage check passed"

    # Publish HTML coverage report
    - task: PublishBuildArtifacts@1
      displayName: 'Publish HTML Coverage Report'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/coverage'
        ArtifactName: 'coverage-report'
        publishLocation: 'Container'

# =============================================================================
# STAGE 4: PACKAGE & SBOM (TAG-TRIGGERED or BRANCH)
# =============================================================================

- stage: Package_and_SBOM
  displayName: 'Package and Generate SBOM'
  dependsOn: 
    - Build_and_Validate
    - Security_Scan
    - Coverage_Analysis
  # Run on Tags AND (Main/Develop) for Artifact Validation
  condition: and(succeeded(), not(startsWith(variables['Build.SourceBranch'], 'refs/tags/security-')), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'), startsWith(variables['Build.SourceBranch'], 'refs/tags/')))
  jobs:
  - job: Package
    displayName: 'Create NuGet Packages and SBOM'
    steps:
    
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        version: $(dotnetVersion)

    # Parse version tag (Only for Tag Builds)
    - task: PowerShell@2
      displayName: 'Parse Version Tag'
      name: parseVersion
      condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/')
      inputs:
        targetType: 'inline'
        script: |
          $tagName = "$(Build.SourceBranchName)"
          Write-Host "=" * 80
          Write-Host "PARSING VERSION TAG: $tagName"
          Write-Host "=" * 80
          
          # Split tag by hyphens
          $parts = $tagName.Split("-")
          
          if ($parts.Length -lt 2) {
            Write-Host "##vso[task.logissue type=error]Invalid tag format. Expected: [type]-[version] or [type]-[version]-[suffix]"
            exit 1
          }
          
          $type = $parts[0]           # release | test | coverage
          $version = $parts[1]        # X.Y.Z
          $suffix = ""
          
          # Check for suffix (rc1, rc2, beta, alpha, etc.)
          if ($parts.Length -gt 2) {
            $suffix = $parts[2]
          }
          
          # Validate type
          $validTypes = @("release", "test", "coverage")
          if ($type -notin $validTypes) {
            Write-Host "##vso[task.logissue type=error]Invalid tag type '$type'. Must be: release, test, or coverage"
            exit 1
          }
          
          # Validate version format (X.Y.Z)
          if ($version -notmatch '^\d+\.\d+\.\d+$') {
            Write-Host "##vso[task.logissue type=error]Invalid version format '$version'. Expected: X.Y.Z (e.g., 1.0.0)"
            exit 1
          }
          
          # Determine full package version
          $fullVersion = if ($suffix) { "$version-$suffix" } else { $version }
          
          # Output variables for Azure DevOps
          Write-Host "##vso[task.setvariable variable=releaseType;isoutput=true]$type"
          Write-Host "##vso[task.setvariable variable=packageVersion;isoutput=true]$version"
          Write-Host "##vso[task.setvariable variable=versionSuffix;isoutput=true]$suffix"
          Write-Host "##vso[task.setvariable variable=fullPackageVersion;isoutput=true]$fullVersion"
          
          Write-Host ""
          Write-Host "âœ… Parsed successfully:" -ForegroundColor Green
          Write-Host "   Type: $type"
          Write-Host "   Version: $version"
          Write-Host "   Suffix: $(if ($suffix) { $suffix } else { '(none)' })"
          Write-Host "   Full Version: $fullVersion"
          Write-Host ""

    # Restore packages
    - task: DotNetCoreCLI@2
      displayName: 'Restore NuGet Packages'
      inputs:
        command: 'restore'
        projects: '$(solutionPath)'
        feedsToUse: 'select'
        # nugetConfigPath: 'NuGet.Config'

    # Build solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: 'build'
        projects: '$(solutionPath)'
        arguments: '--configuration $(buildConfiguration) --no-restore /p:ContinuousIntegrationBuild=true'

    # Pack NuGet Packages (Branch Build) - Standard Versioning
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Packages (Branch)'
      condition: not(startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
      inputs:
        command: 'pack'
        packagesToPack: 'src/**/*.csproj;!src/**/*.Tests.csproj'
        configuration: $(buildConfiguration)
        packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
        nobuild: true
        includesymbols: true
        includesource: false
        versioningScheme: 'off' # Uses csproj version

    # Pack NuGet Packages (Tag Build) - Explicit Version from Tag
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Packages (Tag)'
      condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/')
      inputs:
        command: 'pack'
        packagesToPack: 'src/**/*.csproj;!src/**/*.Tests.csproj'
        configuration: $(buildConfiguration)
        packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
        nobuild: true
        includesymbols: true
        includesource: false
        versioningScheme: 'off'
        buildProperties: 'PackageVersion=$(parseVersion.fullPackageVersion)'

    # Generate SBOM (Software Bill of Materials)
    - task: PowerShell@2
      displayName: 'Generate SBOM (CycloneDX)'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=" * 80
          Write-Host "GENERATING SOFTWARE BILL OF MATERIALS (SBOM)"
          Write-Host "=" * 80
          
          # Install CycloneDX tool
          dotnet tool install --global CycloneDX --version 3.0.0 2>&1 | Out-Null
          
          # Generate SBOM
          $version = if ("$(parseVersion.fullPackageVersion)") { "$(parseVersion.fullPackageVersion)" } else { "build-$(Build.BuildId)" }
          $outputDir = "$(Build.ArtifactStagingDirectory)/sbom"
          New-Item -ItemType Directory -Force -Path $outputDir | Out-Null
          
          dotnet CycloneDX "$(solutionPath)" `
            -o "$outputDir" `
            -f "sbom-$version.json" `
            -sv "$version"
          
          Write-Host ""
          Write-Host "âœ… SBOM generated: sbom-$version.json" -ForegroundColor Green
          Write-Host ""

    # Publish NuGet packages to test feed (Framework Ready - Requires Feed Configuration)
    - task: NuGetCommand@2
      displayName: 'Publish to Test Feed'
      condition: and(succeeded(), eq(variables['parseVersion.releaseType'], 'test'))
      inputs:
        command: 'push'
        packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: 'YourTestFeedName' # <--- UPDATE THIS
        allowPackageConflicts: false

    # Publish NuGet packages to production feed (Framework Ready - Requires Feed Configuration)
    - task: NuGetCommand@2
      displayName: 'Publish to Production Feed'
      condition: and(succeeded(), eq(variables['parseVersion.releaseType'], 'release'))
      inputs:
        command: 'push'
        packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: 'YourProductionFeedName' # <--- UPDATE THIS
        allowPackageConflicts: false

    # Publish NuGet packages as artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish NuGet Packages Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/packages'
        ArtifactName: 'packages'
        publishLocation: 'Container'

    # Publish SBOM as artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish SBOM Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/sbom'
        ArtifactName: 'sbom'
        publishLocation: 'Container'

# =============================================================================
# STAGE 5: DOCUMENTATION REPORT
# =============================================================================

- stage: Documentation_Report
  displayName: 'Documentation Quality Report'
  dependsOn: Build_and_Validate
  condition: succeeded()
  jobs:
  - job: Report
    displayName: 'Generate Documentation Report'
    steps:
    
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        version: $(dotnetVersion)

    # Restore and build
    - task: DotNetCoreCLI@2
      displayName: 'Restore and Build'
      inputs:
        command: 'build'
        projects: '$(solutionPath)'
        arguments: '--configuration $(buildConfiguration)'

    # Generate documentation coverage report
    - task: PowerShell@2
      displayName: 'Generate Documentation Coverage Report'
      inputs:
        targetType: 'filePath'
        filePath: 'cicd/scripts/generate-doc-report.ps1'
        arguments: '-Configuration $(buildConfiguration) -OutputPath "$(Build.ArtifactStagingDirectory)/docs-report"'

    # Publish documentation report
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Documentation Report'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/docs-report'
        ArtifactName: 'documentation-report'
        publishLocation: 'Container'